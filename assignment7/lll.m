function GSO(F, n)
  FS := [];
  M := [];
  for i in [1..n] do
    s := Vector(RealField(),[0.0: i in [1..n]]);
    mui := [];
    for j in [1..i-1] do
      if InnerProduct(FS[j], FS[j]) eq 0 then 
        Append(~mui, 0.0);
      else 
        muij := InnerProduct(Vector(F[i]), FS[j]) / InnerProduct(FS[j],FS[j]);
        Append(~mui, muij);
        s := s + muij * FS[j];
      end if;
    end for;
    for j in [i..n] do
      if j eq i then 
        muij := 1.0;
      else
        muij := 0.0;
      end if;
      Append(~mui, muij);
    end for;
    Append(~FS, Vector(F[i]) - s);
    Append(~M, mui);  
  end for;
  return FS, M;
end function;

/**
LLLCustom([Vector([12.0,2.0]), Vector([13.0,4.0])],2);
[
    (1.00000000000000000000000000000 2.00000000000000000000000000000),
    (9.00000000000000000000000000000 -4.00000000000000000000000000000)
]

LLLCustom([Vector([2.0,3.0])],2);
[(2.00000000000000000000000000000 3.00000000000000000000000000000)]

LLLCustom([Vector([2.0,3.0]),Vector([4.0,6.0])],2);
[
    (2.00000000000000000000000000000 3.00000000000000000000000000000)
]
*/
function LLLCustom(F, n)
  m := #F;
  for i in [m..n-1] do
    Append(~F,Vector([0.0: i in [1..n]]));
  end for;
  Fstar, M := GSO(F,n);
  i := 2;
  while i le n do
    for j := i-1 to 1 by -1 do 
      F[i] := F[i] - Round(M[i][j]) * F[j];
      Fstar, M := GSO(F,n); 
    end for;
    if IsZero(F[i]) ne true and i gt 1 and InnerProduct(Fstar[i-1], Fstar[i-1]) ge 2 * InnerProduct(Fstar[i], Fstar[i])  then 
      Ft := F[i];
      F[i] := F[i-1];
      F[i-1] := Ft;
      Fstar, M := GSO(F,n);
      i := i - 1;
    else 
      i := i + 1;
    end if;
  end while;
  for i:=n to 1 by -1 do
    if IsZero(F[i]) then
      Remove(~F, i); 
    end if;
  end for;
  return F;    
end function;

/**
Running this we find:
> time MinimalPolynom(2^(1/3) + 3^(1/2), 10000000000, 7);
N:  6.93889390390722837764769792557E-18
Polynomial:  [ -23.0000000000000000000000000000,
-36.0000000000000000000000000000, 27.0000000000000000000000000000,
-4.00000000000000000000000000000, -9.00000000000000000000000000000,
0.000000000000000000000000000000, 1.00000000000000000000000000000 ]
(-23.0000000000000000000000000000 -36.0000000000000000000000000000
    27.0000000000000000000000000000 -4.00000000000000000000000000000
    -9.00000000000000000000000000000 0.000000000000000000000000000000
    1.00000000000000000000000000000 6.93889390390722837764769792557E-18)
Time: 0.250
Which stands for -23 - 36x + 27x^2 - 4 x^3 - 9 x ^4 + 0 x ^5 + x^6

> time MinimalPolynom(Cos(6*Pi(RealField()) / 180), 10^25, 9);
N:  0.000488281250000000000000000000000
Polynomial:  [ 1.00000000000000000000000000000,
0.000000000000000000000000000000, -32.0000000000000000000000000000,
0.000000000000000000000000000000, 224.000000000000000000000000000,
0.000000000000000000000000000000, -448.000000000000000000000000000,
0.000000000000000000000000000000, 256.000000000000000000000000000 ]
(1.00000000000000000000000000000 0.000000000000000000000000000000
    -32.0000000000000000000000000000 0.000000000000000000000000000000
    224.000000000000000000000000000 0.000000000000000000000000000000
    -448.000000000000000000000000000 0.000000000000000000000000000000
    256.000000000000000000000000000 0.000488281250000000000000000000000)
Time: 1.680

which corresponds to what Wolframalpha tells us. 

For the complex number we get this result:

> a<i> := ComplexField();
> a:= 0.37327441771435078 + 0.75870016346431320  * i;
> time MinimalPolynom(a, 10^10, 6);
N:  7.22618514423798222190420403876E-10
Polynomial:  [ 1.00000000000000000000000000000,
-1.00000000000000000000000000000, 1.00000000000000000000000000000,
-1.00000000000000000000000000000, 1.00000000000000000000000000000,
-2.00000000000000000000000000000 ]
(1.00000000000000000000000000000 -1.00000000000000000000000000000
    1.00000000000000000000000000000 -1.00000000000000000000000000000
    1.00000000000000000000000000000 -2.00000000000000000000000000000
    3.87847491296497450777476523331E-7 7.22618514423798222190420403876E-10)
Time: 0.120
Which menas there exists a polynomial of with x^5 the biggest factor. 

For the last one it felt a lot like playing slot machines but this is the best result i got. 

> a:= 
> time MinimalPolynom(a, 10^25, 19);
N:  -7.02939790575889089652150687471  ,  0.000000000000000000000000000000
Polynomial:  [ -3.00000000000000000000000000000,
-13.0000000000000000000000000000, -6.00000000000000000000000000000,
-1.00000000000000000000000000000, 9.00000000000000000000000000000,
9.00000000000000000000000000000, 2.00000000000000000000000000000,
3.00000000000000000000000000000, -3.00000000000000000000000000000,
23.0000000000000000000000000000, 1.00000000000000000000000000000,
-8.00000000000000000000000000000, -8.00000000000000000000000000000,
-4.00000000000000000000000000000, 11.0000000000000000000000000000,
5.00000000000000000000000000000, -2.00000000000000000000000000000,
3.00000000000000000000000000000, 1.00000000000000000000000000000 ]
Time: 22.110
*/
function MinimalPolynom(a, N, n) 
  F := [];
  for i in [1..n] do
    row := [];
    for j in [1..n] do 
      if i eq j then
        Append(~row, 1.0); 
      else 
        Append(~row, 0.0);
      end if;
    end for;
    Append(~row, Real(a^(i-1))*N);
    Append(~row, Imaginary(a^(i-1)) * N);
    Append(~F,Vector(RealField(), row));
  end for;
  result := LLLCustom(F,n+2)[1];
  print "N: ", result[Ncols(result)-1] , " , ", result[Ncols(result)];
  print "Polynomial: " , [result[x]: x in [1..n]];
  return result;
end function;

